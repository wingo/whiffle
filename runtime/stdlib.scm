(define (pair? x) (%pair? x))
(define (cons x y) (%cons x y))
(define (car x) (%car x))
(define (cdr x) (%cdr x))
(define (set-car! x y) (%set-car! x y))
(define (set-cdr! x y) (%set-cdr! x y))

(define (+ x y) (%+ x y))
(define (- x y) (%- x y))
(define (* x y) (%* x y))
(define (< x y) (%< x y))
(define (<= x y) (%<= x y))
(define (= x y) (%= x y))
(define (> x y) (%> x y))
(define (>= x y) (%>= x y))
(define (quotient x y) (%quotient x y))
(define (remainder x y) (%remainder x y))

(define (char? x) (%char? x))
(define (char->integer x) (%char->integer x))
(define (integer->char x) (%integer->char x))

(define (eq? x y) (%eq? x y))

(define (string? x) (%string? x))

(define (symbol? x) (%symbol? x))
(define (symbol->string x) (%symbol->string x))

(define (vector? x) (%vector? x))
(define (make-vector x init) (%make-vector x init))
(define-syntax vector
  (lambda (stx)
    (syntax-case stx ()
      ((_ . args) #'(%vector . args))
      (id (identifier? #'id) (lambda args (list->vector args))))))
(define (vector-length x) (%vector-length x))
(define (vector-ref x i) (%vector-ref x i))
(define (vector-set! x i v) (%vector-set! x i v))

(define (null? x) (eq? x '()))
(define (1+ x) (+ x 1))
(define (1- x) (- x 1))
(define (zero? x) (eq? x 0))
(define (not x) (if x #f #t))

(define (map f l)
  (if (null? l)
      '()
      (cons (f (car l)) (map f (cdr l)))))

(define (for-each f l)
  (unless (null? l)
    (f (car l))
    (for-each f (cdr l))))

(define (iota n)
  (let lp ((i 0))
    (if (eq? i n)
        '()
        (cons i (lp (1+ i))))))

(define (list? x)
  (or (null? x)
      (and (pair? x)
           (list? (cdr x)))))

(define (vector->list v)
  (let lp ((i 0))
    (if (< i (vector-length v))
        (cons (vector-ref v i) (lp (1+ i)))
        '())))

(define (string->vector str)
  (call-c-primitive/result "vm_string_to_vector" str))

(define (string->list str)
  (vector->list (string->vector str)))

(define (write-char ch)
  (call-c-primitive "vm_write_char" ch))

(define (write x)
  (define (put-char ch)
    (write-char ch))
  (cond
   ((null? x)
    (put-char #\()
    (put-char #\)))
   ((pair? x)
    (put-char #\()
    (write (car x))
    (let lp ((tail (cdr x)))
      (cond
       ((null? tail)
        (put-char #\)))
       ((pair? tail)
        (put-char #\space)
        (write (car tail))
        (lp (cdr tail)))
       (else
        (put-char #\space)
        (put-char #\.)
        (put-char #\space)
        (write (cdr tail))
        (put-char #\))))))
   ((string? x)
    (put-char #\")
    (for-each (lambda (ch)
                (when (eq? ch #\")
                  (put-char #\\))
                (put-char ch))
              (string->list x))
    (put-char #\"))
   ((symbol? x)
    (for-each put-char (string->list (symbol->string x))))
   ((vector? x)
    (put-char #\#)
    (put-char #\()
    (write (vector->list x))
    (put-char #\)))
   (else
    (write "unhandled object :("))))

(define (display x)
  (define (put-char ch)
    (write-char ch))
  (cond
   ((null? x)
    (put-char #\()
    (put-char #\)))
   ((pair? x)
    (put-char #\()
    (display (car x))
    (let lp ((tail (cdr x)))
      (cond
       ((null? tail)
        (put-char #\)))
       ((pair? tail)
        (put-char #\space)
        (display (car tail))
        (lp (cdr tail)))
       (else
        (put-char #\space)
        (put-char #\.)
        (put-char #\space)
        (display (cdr tail))
        (put-char #\))))))
   ((string? x)
    (for-each put-char (string->list x)))
   ((symbol? x)
    (display (symbol->string x)))
   ((vector? x)
    (put-char #\#)
    (put-char #\()
    (display (vector->list x))
    (put-char #\)))
   (else
    (write "unhandled object :("))))
