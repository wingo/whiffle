#!/bin/sh
# -*- scheme -*-
exec "${GUILE:-guile}" "$0" "$@"
!#
;;; Lightweight Scheme compiler directly to C. -*- scheme -*-
;;; Copyright (C) 2023 Andy Wingo.

;;; This library is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU Lesser General Public License as
;;; published by the Free Software Foundation; either version 3 of the
;;; License, or (at your option) any later version.
;;;
;;; This library is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;; Lesser General Public License for more details.
;;;
;;; You should have received a copy of the GNU Lesser General Public
;;; License along with this program.  If not, see
;;; <http://www.gnu.org/licenses/>.

(use-modules (ice-9 format)
             (ice-9 getopt-long)
             (ice-9 match)
             (ice-9 textual-ports)
             (whiffle run))

(define (parse-args args)
  (define (parse-arg arg)
    (call-with-input-string
     arg
     (lambda (port)
       (match (read port)
         ((? eof-object?) (error "no expression in arg" arg))
         (datum
          (unless (eof-object? (read port))
            (error "more than one expression in arg" arg))
          datum)))))
  (map parse-arg args))

(define (main args)
  (define (usage port)
    (format port "usage: ~a [OPTION...] [INPUT-FILE] ARG...\n" (car args))
    (format port "  available options:\n")
    (format port "    --expr/-e EXPR       input is EXPR instead of a file\n")
    (format port "    --help/-h            print this help message\n")
    (format port "    --output/-o FILE     just compile the input, and write to FILE\n")
    (format port "    --assemble/-S        only produce C file; don't make an executable\n")
    (format port "    --preserve-builddir  keep the build directory around\n")
    (format port "    --optimize/-O LEVEL  optimize at level LEVEL; default is 2\n")
    (format port "    --warn/-W LEVEL      warn at level LEVEL; default is 2\n"))

  (define options
    (getopt-long args
                 '((expr (single-char #\e) (value #t))
                   (help (single-char #\h) (value #f))
                   (assemble (single-char #\S) (value #f))
                   (preserve-builddir (value #f))
                   (optimize (single-char #\O) (value #t))
                   (warn (single-char #\W) (value #t))
                   (output (single-char #\o) (value #t)))))
  (when (option-ref options 'help #f)
    (usage (current-output-port))
    (exit 0))
  (define in-expr
    (option-ref options 'expr #f))
  (define-values (in-file args-to-scheme)
    (let ((args (option-ref options '() #f)))
      (if in-expr
          (values #f args)
          (match args
            ((in . args) (values in args))
            (()
             (usage (current-error-port))
             (exit 1))))))
  (define in-port
    (if in-expr
        (open-input-string in-expr)
        (open-input-file in-file)))
  (define (strip-suffix str suffixes)
    (match suffixes
      (() #f)
      ((suffix . suffixes)
       (if (string-suffix? suffix str)
           (substring str 0 (- (string-length str) (string-length suffix)))
           (strip-suffix str suffixes)))))
  (define assemble?
    (option-ref options 'assemble #f))
  (define preserve-builddir?
    (option-ref options 'preserve-builddir #f))
  (define out-file
    (option-ref options 'output #f))
  (define optimization-level
    (or (and=> (option-ref options 'optimize "2")
               string->number)
        (error "unexpected optimization level")))
  (define warning-level
    (or (and=> (option-ref options 'warn "2")
               string->number)
        (error "unexpected warning level")))
  (define-values results
    (run #:input in-port #:output-file out-file #:assemble? assemble?
         #:args (parse-args args-to-scheme)
         #:optimization-level optimization-level
         #:warning-level warning-level
         #:preserve-builddir? preserve-builddir?))
  (for-each (lambda (datum) (write datum) (newline)) results)
  (exit 0))

(when (batch-mode?)
  (main (program-arguments)))
