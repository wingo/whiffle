#!/bin/sh
# -*- scheme -*-
exec "${GUILE:-guile}" "$0" "$@"
!#
;;; Lightweight Scheme compiler directly to C. -*- scheme -*-
;;; Copyright (C) 2023 Andy Wingo.

;;; This library is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU Lesser General Public License as
;;; published by the Free Software Foundation; either version 3 of the
;;; License, or (at your option) any later version.
;;;
;;; This library is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;; Lesser General Public License for more details.
;;;
;;; You should have received a copy of the GNU Lesser General Public
;;; License along with this program.  If not, see
;;; <http://www.gnu.org/licenses/>.

(use-modules (ice-9 format)
             (ice-9 getopt-long)
             (ice-9 match)
             (ice-9 textual-ports)
             (whiffle compile)
             (whiffle input))

(define whiffle
  (dirname (dirname (canonicalize-path (current-filename)))))

(define (main args)
  (define (usage port)
    (format port "usage: ~a [OPTION...] [INPUT-FILE] ARG...\n" (car args))
    (format port "  available options:\n")
    (format port "    --expr/-e EXPR       input is EXPR instead of a file\n")
    (format port "    --help/-h            print this help message\n")
    (format port "    --output/-o FILE     just compile the input, and write to FILE\n")
    (format port "    --assemble/-S        only produce C file; don't make an executable\n")
    (format port "    --optimize/-O LEVEL  optimize at level LEVEL; default is 2\n")
    (format port "    --warn/-W LEVEL      warn at level LEVEL; default is 2\n"))

  (define options
    (getopt-long args
                 '((expr (single-char #\e) (value #t))
                   (help (single-char #\h) (value #f))
                   (assemble (single-char #\S) (value #f))
                   (compile (single-char #\c) (value #f))
                   (optimize (single-char #\O) (value #t))
                   (warn (single-char #\W) (value #t))
                   (output (single-char #\o) (value #t)))))
  (when (option-ref options 'help #f)
    (usage (current-output-port))
    (exit 0))
  (define in-expr
    (option-ref options 'expr #f))
  (define-values (in-file args-to-scheme)
    (let ((args (option-ref options '() #f)))
      (if in-expr
          (values #f args)
          (match args
            ((in . args) (values in args))
            (()
             (usage (current-error-port))
             (exit 1))))))
  (define in-port
    (if in-expr
        (open-input-string in-expr)
        (open-input-file in-file)))
  (define (strip-suffix str suffixes)
    (match suffixes
      (() #f)
      ((suffix . suffixes)
       (if (string-suffix? suffix str)
           (substring str 0 (- (string-length str) (string-length suffix)))
           (strip-suffix str suffixes)))))
  (define assemble?
    (option-ref options 'assemble #f))
  (define out-file
    (option-ref options 'output #f))
  (define optimization-level
    (or (and=> (option-ref options 'optimize "2")
               string->number)
        (error "unexpected optimization level")))
  (define warning-level
    (or (and=> (option-ref options 'warn "2")
               string->number)
        (error "unexpected warning level")))
  (when (and (or out-file assemble?) (pair? args-to-scheme))
    (error "unexpected args while only compiling or assembling"))
  (define c-code
    (compile-to-c (read-and-expand in-port)
                  #:optimization-level optimization-level
                  #:warning-level warning-level))

  (cond
   (assemble?
    (let ((port (if out-file
                    (open-output-file out-file)
                    (current-output-port))))
      (put-string port c-code)
      (force-output port)))
   (else
    (let* ((dir (mkdtemp (in-vicinity (or (getenv "TMPDIR") "/tmp")
                                      "whiffle-XXXXXX"))))
      (call-with-output-file (in-vicinity dir "out.c")
        (lambda (port)
          (put-string port c-code)))
      (let ((status (system* "make" "--no-print-directory" "-C" dir
                             "-f" (in-vicinity whiffle "build.mk") "V=0"
                             "out")))
        (unless (zero? (status:exit-val status))
          (format (current-error-port)
                  "error: failed to compile generated C; leaving temp dir ~a\n"
                  dir)
          (format (current-error-port)
                  "error: try again via `make -C ~a -f ~a out\n"
                  dir (in-vicinity whiffle "build.mk"))
          (exit 1)))
      (cond
       (out-file
        (rename-file (in-vicinity dir "out") out-file))
       (else
        (let ((status (apply system* (in-vicinity dir "out") args-to-scheme)))
          (cond
           ((status:term-sig status)
            => (lambda (sig)
                 (format (current-error-port)
                         "error when running scheme: killed (~a)\n" sig)
                 (exit 1)))
           ((status:stop-sig status)
            => (lambda (sig)
                 (format (current-error-port)
                         "error when running scheme: stopped (~a)\n" sig)
                 (exit 1)))
           ((not (zero? (status:exit-val status)))
            (format (current-error-port)
                    "error when running scheme: failed (~a)\n" (status:exit-val status))
            (exit 1))))))
      (system* "make" "--no-print-directory" "-C" dir
               "-f" (in-vicinity whiffle "build.mk") "clean" "V=0")
      (delete-file (in-vicinity dir "out.c"))
      (rmdir dir))))
  (exit 0))

(when (batch-mode?)
  (main (program-arguments)))
